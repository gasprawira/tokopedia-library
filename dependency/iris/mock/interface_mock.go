// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

// Package interface_mock is a generated GoMock package.
package interface_mock

import (
	context "context"
	reflect "reflect"

	pubsub "cloud.google.com/go/pubsub"
	iris "github.com/gasprawira/tokopedia-library/dependency/iris"
	gomock "github.com/golang/mock/gomock"
)

// MockLoggerWrapper is a mock of LoggerWrapper interface.
type MockLoggerWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockLoggerWrapperMockRecorder
}

// MockLoggerWrapperMockRecorder is the mock recorder for MockLoggerWrapper.
type MockLoggerWrapperMockRecorder struct {
	mock *MockLoggerWrapper
}

// NewMockLoggerWrapper creates a new mock instance.
func NewMockLoggerWrapper(ctrl *gomock.Controller) *MockLoggerWrapper {
	mock := &MockLoggerWrapper{ctrl: ctrl}
	mock.recorder = &MockLoggerWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoggerWrapper) EXPECT() *MockLoggerWrapperMockRecorder {
	return m.recorder
}

// AddSchemaWithPubsub mocks base method.
func (m *MockLoggerWrapper) AddSchemaWithPubsub(eventName, schema string, config ...pubsub.PublishSettings) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{eventName, schema}
	for _, a := range config {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddSchemaWithPubsub", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddSchemaWithPubsub indicates an expected call of AddSchemaWithPubsub.
func (mr *MockLoggerWrapperMockRecorder) AddSchemaWithPubsub(eventName, schema interface{}, config ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{eventName, schema}, config...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSchemaWithPubsub", reflect.TypeOf((*MockLoggerWrapper)(nil).AddSchemaWithPubsub), varargs...)
}

// Log mocks base method.
func (m *MockLoggerWrapper) Log(eventName string, messageData iris.Data) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", eventName, messageData)
	ret0, _ := ret[0].(error)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockLoggerWrapperMockRecorder) Log(eventName, messageData interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLoggerWrapper)(nil).Log), eventName, messageData)
}

// LogWithContext mocks base method.
func (m *MockLoggerWrapper) LogWithContext(ctx context.Context, eventName string, messageData iris.Data) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogWithContext", ctx, eventName, messageData)
	ret0, _ := ret[0].(error)
	return ret0
}

// LogWithContext indicates an expected call of LogWithContext.
func (mr *MockLoggerWrapperMockRecorder) LogWithContext(ctx, eventName, messageData interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogWithContext", reflect.TypeOf((*MockLoggerWrapper)(nil).LogWithContext), ctx, eventName, messageData)
}

// LogWithPubsub mocks base method.
func (m *MockLoggerWrapper) LogWithPubsub(eventName string, messageData iris.Data) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogWithPubsub", eventName, messageData)
	ret0, _ := ret[0].(error)
	return ret0
}

// LogWithPubsub indicates an expected call of LogWithPubsub.
func (mr *MockLoggerWrapperMockRecorder) LogWithPubsub(eventName, messageData interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogWithPubsub", reflect.TypeOf((*MockLoggerWrapper)(nil).LogWithPubsub), eventName, messageData)
}
